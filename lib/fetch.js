// Generated by CoffeeScript 1.9.3
(function() {
  var Promise, child_process, emitter, events, path, spawn, spawnSync;

  Promise = require('promise-js');

  path = require('path');

  spawn = require('child_process').spawn;

  spawnSync = require('child_process').spawnSync;

  child_process = require('child_process');

  events = require('events');

  emitter = new events.EventEmitter();

  exports.run = function(repository_url, clone_to, argv) {
    var _stdio, clone, cloneParams, clone_shallow, code_cloned, fs, isTmpPresent, tmp_path, tmp_ready, tmp_updated;
    tmp_path = path.join("/tmp/fetcher", repository_url);
    fs = require('fs');
    isTmpPresent = function() {
      var e;
      try {
        fs.accessSync(tmp_path);
        return true;
      } catch (_error) {
        e = _error;
        switch (true) {
          case e.code === 'ENOENT':
            return false;
          default:
            throw e;
        }
      }
    };
    _stdio = ['ignore', process.stdout, process.stderr];
    clone_shallow = function(from, to, extraParams, callback) {
      var clone, params;
      if (extraParams == null) {
        extraParams = [];
      }
      console.log("> clone shallow from " + from + " to " + to);
      params = ['clone', from, to, '--depth', '1', '--progress'];
      params = params.concat(extraParams);
      clone = spawn("git", params, {
        stdio: _stdio
      });
      return clone.on('close', function(code) {
        if (code === 0) {
          return callback(code);
        }
        throw "clone shallow error, code returned: " + code;
      });
    };
    clone = function(from, to, extraParams, callback) {
      var params;
      if (extraParams == null) {
        extraParams = [];
      }
      console.log("> clone from " + from + " to " + to);
      params = ['clone', from, to, '--progress'];
      params = params.concat(extraParams);
      clone = spawn("git", params, {
        stdio: _stdio
      });
      return clone.on('close', function(code) {
        if (code === 0) {
          return callback(code);
        }
        throw "clone shallow error, code returned: " + code;
      });
    };
    cloneParams = [];
    if (argv.branch) {
      cloneParams = ['--branch', argv.branch];
    }
    if (isTmpPresent()) {
      tmp_updated = new Promise(function(resolve) {
        var child;
        console.log("> update tmp mirror");
        child = spawn("git", ["remote", "update"], {
          stdio: _stdio,
          cwd: tmp_path
        });
        return child.on('close', function(code) {
          if (code === 0) {
            return resolve(code);
          }
          throw "tmp update error, code returned: " + code;
        });
      });
      code_cloned = new Promise(function(resolve) {
        return tmp_updated.then(function() {
          return clone(tmp_path, clone_to, cloneParams, resolve);
        });
      });
      return code_cloned.then(function() {
        console.log("code cloned");
        spawnSync("git", ["remote", "rename", "origin", "tmp"], {
          cwd: clone_to,
          stdio: _stdio
        });
        spawnSync("git", ["remote", "add", "origin", repository_url], {
          cwd: clone_to,
          stdio: _stdio
        });
        spawnSync("git", ["config", "--replace-all", "remote.origin.fetch", "+refs/heads/*:refs/remotes/origin/*"], {
          cwd: clone_to
        });
        return spawnSync("git", ["fetch", "origin"], {
          cwd: clone_to
        });
      });
    } else {
      code_cloned = new Promise(function(resolve) {
        return clone_shallow(repository_url, clone_to, cloneParams, resolve);
      });
      return tmp_ready = code_cloned.then(function() {
        var child, command, err, out;
        fs = require("fs");
        command = "./make_tmp_and_unshallow.sh";
        out = fs.openSync(command + ".log", 'a');
        err = fs.openSync(command + ".log", 'a');
        child = spawn(command, [repository_url, tmp_path, clone_to], {
          detached: true,
          stdio: ['ignore', out, err]
        });
        console.log("> local mirror repo (" + tmp_path + ") will be created in the background \n\t\tboth " + tmp_path + " and " + clone_to + " will be unshallowed afterwards \n\t\tyou can watch progress with tail -f " + command + ".log \n\t\tyou can use your code as soon as this script exits");
        return child.unref();
      });
    }
  };

}).call(this);

//# sourceMappingURL=fetch.js.map
